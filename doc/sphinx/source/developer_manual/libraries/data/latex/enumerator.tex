\documentclass{article}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{fullpage}

\newtheorem{theorem}{Theorem}
\newtheorem{acknowledgement}[theorem]{Acknowledgement}
\newtheorem{algorithm}[theorem]{Algorithm}
\newtheorem{axiom}[theorem]{Axiom}
\newtheorem{case}[theorem]{Case}
\newtheorem{claim}[theorem]{Claim}
\newtheorem{conclusion}[theorem]{Conclusion}
\newtheorem{condition}[theorem]{Condition}
\newtheorem{conjecture}[theorem]{Conjecture}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{criterion}[theorem]{Criterion}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{example}[theorem]{Example}
\newtheorem{exercise}[theorem]{Exercise}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{notation}[theorem]{Notation}
\newtheorem{problem}[theorem]{Problem}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{remark}[theorem]{Remark}
\newtheorem{solution}[theorem]{Solution}
\newtheorem{summary}[theorem]{Summary}
\newenvironment{proof}[1][Proof]{\noindent\textbf{#1.} }{\ \rule{0.5em}{0.5em}}
\newcommand{\concat}{\ensuremath{+\!\!+}}
\begin{document}

\title{Enumerator}
\author{Wieger Wesselink}
\maketitle

This document specifies an algorithm for enumeration. Given an expression $\varphi$ and
a list of data variables $v$, the algorithm will iteratively report expressions
$[\varphi_0, \varphi_1, \ldots]$ that can be obtained from $\varphi$ by assigning
constant values to the variables in $v$.

Let $R$ be a rewriter on expressions of type $T$, let $r$ be a rewriter on
data expressions, and let $\sigma $ a substitution on data variables that is
applied during rewriting with $R$. Furthermore let $P$ be a queue of pairs
$\left\langle v,\varphi \right\rangle$, with $v$ a non-empty list of variables and
$\varphi$ an expression. The predicate function $accept$ is used to discard
expressions. This is not just a cosmetic detail. The termination of the
enumeration may depend on it.

We assume that for each sort $s$ a non-empty set of
constructor functions $\mathrm{constructors}(s)$ is defined.

\[
\begin{tabular}{l}
\textsc{Enumerate}($P,R,r,\sigma, accept)$ \\
\textbf{while} $P\neq \emptyset $ \textbf{do} \\
\qquad \textbf{let} $\left\langle v,\varphi \right\rangle =\mathrm{head}(P)$ \\
\qquad \textbf{if } $\neg accept(\varphi)$ \textbf{ then continue} \\
%--- finite sorts ---%
\qquad \textbf{if } $\mathrm{is\_finite}(\mathrm{sort}(v_{1}))$ \textbf{ then} \\
\qquad \qquad \textbf{for} $e\in \mathrm{values}(\mathrm{sort}(v_{1}))$ \textbf{do} \\
\qquad \qquad \qquad $\varphi^{\prime}:=R(\varphi,\sigma[v_{1}:=e])$ \\
\qquad \qquad \qquad \textbf{if } $\neg accept(\varphi')$ \textbf{ then continue} \\
\qquad \qquad \qquad \textbf{if } $\mathrm{tail}(v) = []$ \textbf{ then} \textsc{ReportSolution}($\varphi', \sigma$) \\
\qquad \qquad \qquad \textbf{else } $P:=P\concat\lbrack \left\langle \mathrm{tail}(v), \varphi' \right\rangle ]$ \\
%--- function sort ---%
\qquad \textbf{else } \\
\qquad \qquad \textbf{for} $c\in $ $\mathrm{constructors}(\mathrm{sort}(v_{1}))$ \textbf{do} \\
\qquad \qquad \qquad \textbf{let} $c:D_{1}\times \ldots \times
D_{m}\rightarrow \mathrm{sort}(v_{1})$ \\
\qquad \qquad \qquad \textbf{choose }$y_{1},\ldots ,y_{m}$
\textbf{such} that $y_i \notin \{ v_1, \ldots ,v_n \} \cup FV(\varphi)$, for $i=1, \cdots, m$ \\
\qquad \qquad \qquad $\varphi ^{\prime }:=R(\varphi ,\sigma \lbrack v_{1}:=r(c(y_{1},\ldots ,y_{m}))])$ \\
\qquad \qquad \qquad \textbf{if } $\neg accept(\varphi')$ \textbf{ then continue} \\
\qquad \qquad \qquad \textbf{if } $\mathrm{tail}(v) = []$ \textbf{ then} \\
\qquad \qquad \qquad \qquad \textsc{ReportSolution}($\varphi', \sigma$) \\
\qquad \qquad \qquad \textbf{else} \\
\qquad \qquad \qquad \qquad \textbf{if } $\varphi = \varphi'$ \textbf{ then }
$P:=P\concat\lbrack \left\langle \mathrm{tail}(v),\varphi'\right\rangle ]$ \\
\qquad \qquad \qquad \qquad \textbf{else}
$P:=P\concat\lbrack \left\langle \mathrm{tail}(v) \concat [y_{1},\ldots ,y_{m}],\varphi'\right\rangle ]$ \\
\qquad $P:=\mathrm{tail}(P)$
\end{tabular}
\]

\begin{remark}
The algorithm works both for data expressions and PBES expressions.
\end{remark}

\begin{remark}
In the case of data expressions, $R$ and $r$ may coincide.%
\end{remark}

\begin{remark}
The algorithm can be extended such that it also returns the assignments
corresponding a solution.
\end{remark}

\end{document}
