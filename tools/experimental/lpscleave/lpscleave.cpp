// Author(s): Maurice Laveaux
// Copyright: see the accompanying file COPYING or copy at
// https://github.com/mCRL2org/mCRL2/blob/master/COPYING
//
// Distributed under the Boost Software License, Version 1.0.
// (See accompanying file LICENSE_1_0.txt or copy at
// http://www.boost.org/LICENSE_1_0.txt)
//

#include "mcrl2/lps/stochastic_specification.h"
#include "mcrl2/lps/io.h"
#include "mcrl2/utilities/logger.h"
#include "mcrl2/utilities/input_output_tool.h"

#include <fstream>
#include <iostream>
#include <list>
#include <string>
#include <vector>

namespace mcrl2
{

using log::log_level_t;
using utilities::tools::input_output_tool;
using lps::stochastic_specification;

/// \brief Splits a string generated by [x,]* into a set of x's.
static
std::list<std::string> split_actions(const std::string& s)
{
  std::size_t pcount = 0;
  std::string a;
  std::list<std::string> result;
  for (std::string::const_iterator i = s.begin(); i != s.end(); ++i)
  {
    if (*i == ',' && pcount == 0)
    {
      result.push_back(a);
      a.clear();
    }
    else
    {
      if (*i == '(') ++pcount;
      else if (*i == ')') --pcount;
      a.push_back(*i);
    }
  }

  if (!a.empty())
  {
    result.push_back(a);
  }
  return result;
}

/// \brief Prints the parameters of the given LPS as comma separated values.
void print_parameters(const stochastic_specification& spec)
{
  bool first = true;
  for (auto& param : spec.process().process_parameters())
  {
    if (!first)
    {
      mCRL2log(log_level_t::info) << ", ";
    }
    mCRL2log(log_level_t::info) << param.name();
    first = false;
  }

  mCRL2log(log_level_t::info) << "\n";
}

/// \brief Projects a list of parameters based on a list of names.
/// \returns A list that only contains those parameters of the given parameter list that are contained in the list of names.
data::variable_list get_parameters(data::variable_list& param_list, const std::list<std::string>& parameters)
{
  data::variable_list result;
  for (const std::string& param : parameters)
  {
    auto it = std::find_if(param_list.begin(), param_list.end(), [&](const data::variable& var) -> bool { return static_cast<std::string>(var.name()) == param; } );
    if (it != param_list.end())
    {
      result.push_front(*it);
    }
    else
    {
      mCRL2log(log_level_t::warning) << "Warning parameter " << param << " is not a parameter of the process.\n";
    }
  }

  return result;
}

/// \brief Given a list of assignments and parameters returns a list of assignments that only contain the assignments
///        for the given parameters and not for the potential other variables.
/// \returns A list of assignments only over the given parameters.
data::assignment_list project(const data::assignment_list& assignments, const data::variable_list& parameters)
{
  data::assignment_list result;
  for (auto& assignment : assignments)
  {
    // If the variable is in the parameters then copy the assignment.
    if (std::find_if(parameters.begin(), parameters.end(), [&](const data::variable& param) -> bool { return param == assignment.lhs(); } ) != parameters.end())
    {
      result.push_front(assignment);
    }
  }

  return result;
}

/// \brief Creates a single summand for the cleave process.
template<bool owning = false>
lps::stochastic_action_summand cleave_summand(const lps::stochastic_action_summand& summand,
  std::size_t summand_index,
  const data::variable_list& parameters,
  const data::variable_list& other_parameters,
  std::vector<process::action_label>& sync_labels)
{

  // Add a summation for every parameter of the other process.
  data::variable_list variables = summand.summation_variables();
  for (auto& variable : other_parameters)
  {
    variables.push_front(variable);
  }

  // Create the actsync(p, e_i) action
  data::data_expression_list values;
  data::sort_expression_list sorts;
  for (auto& param : parameters)
  {
    values.push_front(data::data_expression(param));
    sorts.push_front(param.sort());
  }

  for (auto& param : other_parameters)
  {
    values.push_front(data::data_expression(param));
    sorts.push_front(param.sort());
  }

  for (auto& variable : summand.summation_variables())
  {
    values.push_front(data::data_expression(variable));
    sorts.push_front(variable.sort());
  }

  sync_labels.emplace_back(std::string("actsync_") += std::to_string(summand_index), sorts);

  lps::multi_action action;
  if (owning)
  {
    process::action_list actions = summand.multi_action().actions();
    actions.push_front(process::action(sync_labels.back(), values));
    action = lps::multi_action(actions);
  }
  else
  {
    process::action_list actions;
    actions.push_front(process::action(sync_labels.back(), values));
    action = lps::multi_action(actions);
  }

  return lps::stochastic_action_summand(variables, summand.condition(), action, project(summand.assignments(), parameters), summand.distribution());
}

/// \brief Performs the a naive cleave.
stochastic_specification cleave(const stochastic_specification& spec, const data::variable_list& parameters, const std::list<std::size_t>& indices)
{
  // Check sanity conditions, no timed or stochastic processes.
  auto& process = spec.process();

  if (process.has_time())
  {
    throw runtime_error("Cleave does not support timed processes");
  }

  // The parameters of the "other" component process.
  data::variable_list other_parameters;

  for (auto& param : process.process_parameters())
  {
    if (std::find(parameters.begin(), parameters.end(), param) == parameters.end())
    {
      other_parameters.push_front(param);
    }
  }

  // Extend the action specification with an actsync (that is unique) for every summand with the correct sorts.
  std::vector<process::action_label> sync_labels;

  // Change the summands to include the parameters of the other process and added the sync action.
  lps::stochastic_action_summand_vector cleave_summands;

  // Add the summands that generate the action label.
  for (auto& index : indices)
  {
    cleave_summands.push_back(cleave_summand<true>(process.action_summands()[index], index, parameters, other_parameters, sync_labels));
  }

  // Add the other summand that do not own the action. Indices should be sorted before this loop.
  auto it = indices.begin();
  for (std::size_t index = 0; index < process.action_summands().size(); ++index)
  {
    // Invariant: The index of *it is always higher than the loop index or it is the end
    if (it != indices.end())
    {
      if (*it < index)
      {
        // We have past the last index of the array.
        ++it;
      }
      if (it != indices.end() && *it == index)
      {
        // This summand was already created above.
        continue;
      }
    }

    // Index is not an element of indices.
    cleave_summands.push_back(cleave_summand<false>(process.action_summands()[index], index, parameters, other_parameters, sync_labels));
  }

  // Add the labels to the LPS action specification.
  auto cleave_action_labels = spec.action_labels();
  for (auto& label : sync_labels)
  {
    cleave_action_labels.push_front(label);
  }

  lps::deadlock_summand_vector no_deadlock_summands;
  lps::stochastic_linear_process cleave_process(parameters, no_deadlock_summands, cleave_summands);

  lps::stochastic_process_initializer cleave_initial(project(spec.initial_process().assignments(), parameters), spec.initial_process().distribution());

  // Create the new LPS and return it.
  return stochastic_specification(spec.data(), cleave_action_labels, spec.global_variables(), cleave_process, cleave_initial);
}

class lpscleave_tool : public input_output_tool
{
    typedef input_output_tool super;

  public:
    lpscleave_tool() : super(
        "lpscleave",
        "Maurice Laveaux",
        "Cleaves LPSs",
        "")
    {}

    bool run() override
    {
      stochastic_specification spec;
      load_lps(spec, input_filename());

      if (m_parameters.empty())
      {
        // Print the parameters and exit
        print_parameters(spec);
      }
      else
      {
        // Here, we should decide on a good cleaving.

        // For now, the parameters are given by the user.
        auto parameters = get_parameters(spec.process().process_parameters(), m_parameters);

        // Cleave the process, requires the indices to be sorted.
        m_indices.sort();
        stochastic_specification left_cleave = cleave(spec, parameters, m_indices);

        // Save the resulting cleave.
        std::ofstream file(output_filename(), std::ios::binary);
        left_cleave.save(file, true);
      }

      return true;
    }

  protected:
    void add_options(utilities::interface_description& desc) override
    {
      super::add_options(desc);

      desc.add_option("parameters", utilities::make_mandatory_argument("PARAMS"), "A comma separated list of PARAMS that are used for the left process of the cleave.", 'p');
      desc.add_option("summands", utilities::make_mandatory_argument("INDICEs"), "A comma separated list of INDICES of summands where the left process generates the action.", 's');
    }

    void parse_options(const utilities::command_line_parser& parser) override
    {
      super::parse_options(parser);

      if (parser.options.count("parameters"))
      {
        m_parameters = split_actions(parser.option_argument("parameters"));
      }

      if (parser.options.count("summands"))
      {
        std::list<std::string> indices = split_actions(parser.option_argument("summands"));
        for (auto& index : indices)
        {
          m_indices.push_back(std::atoi(index.c_str()));
        }
      }
    }

  private:

    std::list<std::string> m_parameters;
    std::list<std::size_t> m_indices;
};

} // namespace mcrl2

int main(int argc, char** argv)
{
  return mcrl2::lpscleave_tool().execute(argc, argv);
}
